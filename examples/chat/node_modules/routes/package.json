{
  "name": "routes",
  "description": "Minimalist route matching for javascript",
  "version": "0.1.1",
  "homepage": "https://github.com/aaronblohowiak/routes.js",
  "repository": {
    "type": "git",
    "url": "https://github.com/aaronblohowiak/routes.js.git"
  },
  "author": {
    "name": "Aaron Blohowiak",
    "email": "aaron.blohowiak@gmail.com",
    "url": "http://github.com/aaronblohowiak"
  },
  "main": "index",
  "directories": {
    "lib": "."
  },
  "scripts": {
    "test": "make test"
  },
  "engines": {
    "node": "*"
  },
  "readme": "# Routes.js\n\n`routes` lets you easily dispatch based on url-style strings.  It comes with a default Router function that you can use to route http requests, but it also cleanly exposes the important functionality so you could also use it to perform more generic string pattern matching.\n\nThis might make it useful for things like:\n\n1. URI routing\n2. Cucumber-style pattern matching :)\n3. Routing messages by channel name from an MQ\n4. Dispatching hierarchical events by name\n\n\n## Router Example:\n\nThe full range of `Path Formats` is documented below.\n\n    var router = new require('routes').Router();\n    var noop = function(){};\n\n    router.addRoute(\"/articles/:title?\", noop);\n    router.addRoute(\"/:controller/:action/:id.:format?\", noop);\n\n    console.log(router.match(\"/articles\"));\n    console.log(router.match(\"/articles/never-gonna-let-you-down\"));\n    console.log(router.match(\"/posts/show/1.json\"));\n\nThe output for `router.match(\"/posts/show/1.json\")` would be:\n\n    { params: \n       { controller: 'posts',\n         action: 'show',\n         id: '1',\n         format: 'json' },\n      splats: [],\n      route: '/:controller/:action/:id.:format?',\n      fn: [Function] }\n  \nIn the example above, fn would be the function that was passed into the router.\n\n\nI return this object instead of calling your function for you because you will likely want to add additional parameters from the current context to the function invocation. Ex:\n\n    var route = router.match(\"/posts/show/1.json\");\n    route.fn.apply([req, res, route.params, route.splats]);\n\n## Installation\n\n`npm install routes`\n\n## Path Formats\n\nBasic string:\n\n    \"/articles\" will only match routes that == \"/articles\".\n\nNamed parameters:\n\n    \"/articles/:title\" will only match routes like \"/articles/hello\", but *not* \"/articles/\".\n\nOptional named parameters:\n\n    \"/articles/:title?\" will match \"/articles/hello\" AND \"/articles/\"\n\nPeriods before optional parameters are also optional:\n\n    \"/:n.:f?\" will match \"/1\" and \"/1.json\"\n\nSplaaaat! :\n\n    \"/assets/*\" will match \"/assets/blah/blah/blah.png\" and \"/assets/\".\n    \n    \"/assets/*.*\" will match \"/assets/1/2/3.js\" as splats: [\"1/2/3\", \"js\"]\n\nMix splat with named parameters:\n\n    \"/account/:id/assets/*\" will match \"/account/2/assets/folder.png\" as params: {id: 2}, splats:[\"folder.png\"]\n\n\nNamed RegExp:\n\n    \"/lang/:lang([a-z]{2})\" will match \"/lang/en\" but not \"/lang/12\" or \"/lang/eng\"\n\nRaw RegExp:\n\n    /^\\/(\\d{2,3}-\\d{2,3}-\\d{4})\\.(\\w*)$/ (note no quotes, this is a RegExp, not a string.) will match \"/123-22-1234.json\". Each match group will be an entry in splats: [\"123-22-1234\", \"json\"]\n\n\n## Router API\n\nThe `Router()` that `routes` exposes has two functions: `addRoute` and `match`.\n\n`addRoute`: takes a `path` and a `fn`. Your `path` can match any of the formats in the \"Path Formats\" section.\n\n`match`: takes a `String` and returns an object that contains the named `params`, `splats`, `route` (string that was matched against), and the `fn` handler you passed in with `addRoute`\n\n## Library API\n\n`match`: takes an array of `Routes`, and a `String`. Goes through `Routes` and returns an object for the first `Route` that matches the `String`, or 'undefined' if none is found. The result object contains `params`, `splats`, and `route`. `params` is an object containing the named matches, `splats` contains the unnamed globs (\"*\") and `route` contains the original string that was matched against.\n\n`pathToRegExp`: takes a `path` string and an empty array, `keys`.  Returns a RegExp and populates `keys` with the names of the match groups that the RegExp will match. This is largely an internal function but is provided in case someone wants to make a nifty string -> [RegExp, keys] utility.\n\n\n## Test\n\nClone the repo, cd to it and:\n\n`make test`\n\n## Credits\n\nThis library is an extraction and re-factor of the `connect` `router` middleware.  I found that connect-based routing worked reasonably well on the server side, but I wanted to do similar routing based on channel names when using `Push-It` and possibly for event names when using `Evan`.  So, I extracted the relevant goodness out of the `router` middleware and presented it here.  Big thanks to TJ Holowaychuk for writing the original `router` middleware.\n\n## License\n\nThis code is distributed under the MIT license, Copyright Aaron Blohowiak and TJ Holowaychuk 2011.",
  "readmeFilename": "README.md",
  "_id": "routes@0.1.1",
  "dist": {
    "shasum": "7e8118ad02af2b1d42d29d688cb65f025d11ad5c"
  },
  "_from": "routes"
}
